// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/golang/protobuf/ptypes/timestamp"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

type MockStub struct {
	GetArgsStub        func() [][]byte
	getArgsMutex       sync.RWMutex
	getArgsArgsForCall []struct{}
	getArgsReturns     struct {
		result1 [][]byte
	}
	getArgsReturnsOnCall map[int]struct {
		result1 [][]byte
	}
	GetStringArgsStub        func() []string
	getStringArgsMutex       sync.RWMutex
	getStringArgsArgsForCall []struct{}
	getStringArgsReturns     struct {
		result1 []string
	}
	getStringArgsReturnsOnCall map[int]struct {
		result1 []string
	}
	GetFunctionAndParametersStub        func() (string, []string)
	getFunctionAndParametersMutex       sync.RWMutex
	getFunctionAndParametersArgsForCall []struct{}
	getFunctionAndParametersReturns     struct {
		result1 string
		result2 []string
	}
	getFunctionAndParametersReturnsOnCall map[int]struct {
		result1 string
		result2 []string
	}
	GetArgsSliceStub        func() ([]byte, error)
	getArgsSliceMutex       sync.RWMutex
	getArgsSliceArgsForCall []struct{}
	getArgsSliceReturns     struct {
		result1 []byte
		result2 error
	}
	getArgsSliceReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetTxIDStub        func() string
	getTxIDMutex       sync.RWMutex
	getTxIDArgsForCall []struct{}
	getTxIDReturns     struct {
		result1 string
	}
	getTxIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetChannelIDStub        func() string
	getChannelIDMutex       sync.RWMutex
	getChannelIDArgsForCall []struct{}
	getChannelIDReturns     struct {
		result1 string
	}
	getChannelIDReturnsOnCall map[int]struct {
		result1 string
	}
	InvokeChaincodeStub        func(chaincodeName string, args [][]byte, channel string) pb.Response
	invokeChaincodeMutex       sync.RWMutex
	invokeChaincodeArgsForCall []struct {
		chaincodeName string
		args          [][]byte
		channel       string
	}
	invokeChaincodeReturns struct {
		result1 pb.Response
	}
	invokeChaincodeReturnsOnCall map[int]struct {
		result1 pb.Response
	}
	GetStateStub        func(key string) ([]byte, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
		key string
	}
	getStateReturns struct {
		result1 []byte
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	PutStateStub        func(key string, value []byte) error
	putStateMutex       sync.RWMutex
	putStateArgsForCall []struct {
		key   string
		value []byte
	}
	putStateReturns struct {
		result1 error
	}
	putStateReturnsOnCall map[int]struct {
		result1 error
	}
	DelStateStub        func(key string) error
	delStateMutex       sync.RWMutex
	delStateArgsForCall []struct {
		key string
	}
	delStateReturns struct {
		result1 error
	}
	delStateReturnsOnCall map[int]struct {
		result1 error
	}
	GetStateByRangeStub        func(startKey, endKey string) (shim.StateQueryIteratorInterface, error)
	getStateByRangeMutex       sync.RWMutex
	getStateByRangeArgsForCall []struct {
		startKey string
		endKey   string
	}
	getStateByRangeReturns struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}
	getStateByRangeReturnsOnCall map[int]struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}
	GetStateByPartialCompositeKeyStub        func(objectType string, keys []string) (shim.StateQueryIteratorInterface, error)
	getStateByPartialCompositeKeyMutex       sync.RWMutex
	getStateByPartialCompositeKeyArgsForCall []struct {
		objectType string
		keys       []string
	}
	getStateByPartialCompositeKeyReturns struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}
	getStateByPartialCompositeKeyReturnsOnCall map[int]struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}
	CreateCompositeKeyStub        func(objectType string, attributes []string) (string, error)
	createCompositeKeyMutex       sync.RWMutex
	createCompositeKeyArgsForCall []struct {
		objectType string
		attributes []string
	}
	createCompositeKeyReturns struct {
		result1 string
		result2 error
	}
	createCompositeKeyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SplitCompositeKeyStub        func(compositeKey string) (string, []string, error)
	splitCompositeKeyMutex       sync.RWMutex
	splitCompositeKeyArgsForCall []struct {
		compositeKey string
	}
	splitCompositeKeyReturns struct {
		result1 string
		result2 []string
		result3 error
	}
	splitCompositeKeyReturnsOnCall map[int]struct {
		result1 string
		result2 []string
		result3 error
	}
	GetQueryResultStub        func(query string) (shim.StateQueryIteratorInterface, error)
	getQueryResultMutex       sync.RWMutex
	getQueryResultArgsForCall []struct {
		query string
	}
	getQueryResultReturns struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}
	getQueryResultReturnsOnCall map[int]struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}
	GetHistoryForKeyStub        func(key string) (shim.HistoryQueryIteratorInterface, error)
	getHistoryForKeyMutex       sync.RWMutex
	getHistoryForKeyArgsForCall []struct {
		key string
	}
	getHistoryForKeyReturns struct {
		result1 shim.HistoryQueryIteratorInterface
		result2 error
	}
	getHistoryForKeyReturnsOnCall map[int]struct {
		result1 shim.HistoryQueryIteratorInterface
		result2 error
	}
	GetCreatorStub        func() ([]byte, error)
	getCreatorMutex       sync.RWMutex
	getCreatorArgsForCall []struct{}
	getCreatorReturns     struct {
		result1 []byte
		result2 error
	}
	getCreatorReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetTransientStub        func() (map[string][]byte, error)
	getTransientMutex       sync.RWMutex
	getTransientArgsForCall []struct{}
	getTransientReturns     struct {
		result1 map[string][]byte
		result2 error
	}
	getTransientReturnsOnCall map[int]struct {
		result1 map[string][]byte
		result2 error
	}
	GetBindingStub        func() ([]byte, error)
	getBindingMutex       sync.RWMutex
	getBindingArgsForCall []struct{}
	getBindingReturns     struct {
		result1 []byte
		result2 error
	}
	getBindingReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetDecorationsStub        func() map[string][]byte
	getDecorationsMutex       sync.RWMutex
	getDecorationsArgsForCall []struct{}
	getDecorationsReturns     struct {
		result1 map[string][]byte
	}
	getDecorationsReturnsOnCall map[int]struct {
		result1 map[string][]byte
	}
	GetSignedProposalStub        func() (*pb.SignedProposal, error)
	getSignedProposalMutex       sync.RWMutex
	getSignedProposalArgsForCall []struct{}
	getSignedProposalReturns     struct {
		result1 *pb.SignedProposal
		result2 error
	}
	getSignedProposalReturnsOnCall map[int]struct {
		result1 *pb.SignedProposal
		result2 error
	}
	GetTxTimestampStub        func() (*timestamp.Timestamp, error)
	getTxTimestampMutex       sync.RWMutex
	getTxTimestampArgsForCall []struct{}
	getTxTimestampReturns     struct {
		result1 *timestamp.Timestamp
		result2 error
	}
	getTxTimestampReturnsOnCall map[int]struct {
		result1 *timestamp.Timestamp
		result2 error
	}
	SetEventStub        func(name string, payload []byte) error
	setEventMutex       sync.RWMutex
	setEventArgsForCall []struct {
		name    string
		payload []byte
	}
	setEventReturns struct {
		result1 error
	}
	setEventReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *MockStub) GetArgs() [][]byte {
	fake.getArgsMutex.Lock()
	ret, specificReturn := fake.getArgsReturnsOnCall[len(fake.getArgsArgsForCall)]
	fake.getArgsArgsForCall = append(fake.getArgsArgsForCall, struct{}{})
	fake.recordInvocation("GetArgs", []interface{}{})
	fake.getArgsMutex.Unlock()
	if fake.GetArgsStub != nil {
		return fake.GetArgsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getArgsReturns.result1
}

func (fake *MockStub) GetArgsCallCount() int {
	fake.getArgsMutex.RLock()
	defer fake.getArgsMutex.RUnlock()
	return len(fake.getArgsArgsForCall)
}

func (fake *MockStub) GetArgsReturns(result1 [][]byte) {
	fake.GetArgsStub = nil
	fake.getArgsReturns = struct {
		result1 [][]byte
	}{result1}
}

func (fake *MockStub) GetArgsReturnsOnCall(i int, result1 [][]byte) {
	fake.GetArgsStub = nil
	if fake.getArgsReturnsOnCall == nil {
		fake.getArgsReturnsOnCall = make(map[int]struct {
			result1 [][]byte
		})
	}
	fake.getArgsReturnsOnCall[i] = struct {
		result1 [][]byte
	}{result1}
}

func (fake *MockStub) GetStringArgs() []string {
	fake.getStringArgsMutex.Lock()
	ret, specificReturn := fake.getStringArgsReturnsOnCall[len(fake.getStringArgsArgsForCall)]
	fake.getStringArgsArgsForCall = append(fake.getStringArgsArgsForCall, struct{}{})
	fake.recordInvocation("GetStringArgs", []interface{}{})
	fake.getStringArgsMutex.Unlock()
	if fake.GetStringArgsStub != nil {
		return fake.GetStringArgsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStringArgsReturns.result1
}

func (fake *MockStub) GetStringArgsCallCount() int {
	fake.getStringArgsMutex.RLock()
	defer fake.getStringArgsMutex.RUnlock()
	return len(fake.getStringArgsArgsForCall)
}

func (fake *MockStub) GetStringArgsReturns(result1 []string) {
	fake.GetStringArgsStub = nil
	fake.getStringArgsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *MockStub) GetStringArgsReturnsOnCall(i int, result1 []string) {
	fake.GetStringArgsStub = nil
	if fake.getStringArgsReturnsOnCall == nil {
		fake.getStringArgsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getStringArgsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *MockStub) GetFunctionAndParameters() (string, []string) {
	fake.getFunctionAndParametersMutex.Lock()
	ret, specificReturn := fake.getFunctionAndParametersReturnsOnCall[len(fake.getFunctionAndParametersArgsForCall)]
	fake.getFunctionAndParametersArgsForCall = append(fake.getFunctionAndParametersArgsForCall, struct{}{})
	fake.recordInvocation("GetFunctionAndParameters", []interface{}{})
	fake.getFunctionAndParametersMutex.Unlock()
	if fake.GetFunctionAndParametersStub != nil {
		return fake.GetFunctionAndParametersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getFunctionAndParametersReturns.result1, fake.getFunctionAndParametersReturns.result2
}

func (fake *MockStub) GetFunctionAndParametersCallCount() int {
	fake.getFunctionAndParametersMutex.RLock()
	defer fake.getFunctionAndParametersMutex.RUnlock()
	return len(fake.getFunctionAndParametersArgsForCall)
}

func (fake *MockStub) GetFunctionAndParametersReturns(result1 string, result2 []string) {
	fake.GetFunctionAndParametersStub = nil
	fake.getFunctionAndParametersReturns = struct {
		result1 string
		result2 []string
	}{result1, result2}
}

func (fake *MockStub) GetFunctionAndParametersReturnsOnCall(i int, result1 string, result2 []string) {
	fake.GetFunctionAndParametersStub = nil
	if fake.getFunctionAndParametersReturnsOnCall == nil {
		fake.getFunctionAndParametersReturnsOnCall = make(map[int]struct {
			result1 string
			result2 []string
		})
	}
	fake.getFunctionAndParametersReturnsOnCall[i] = struct {
		result1 string
		result2 []string
	}{result1, result2}
}

func (fake *MockStub) GetArgsSlice() ([]byte, error) {
	fake.getArgsSliceMutex.Lock()
	ret, specificReturn := fake.getArgsSliceReturnsOnCall[len(fake.getArgsSliceArgsForCall)]
	fake.getArgsSliceArgsForCall = append(fake.getArgsSliceArgsForCall, struct{}{})
	fake.recordInvocation("GetArgsSlice", []interface{}{})
	fake.getArgsSliceMutex.Unlock()
	if fake.GetArgsSliceStub != nil {
		return fake.GetArgsSliceStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getArgsSliceReturns.result1, fake.getArgsSliceReturns.result2
}

func (fake *MockStub) GetArgsSliceCallCount() int {
	fake.getArgsSliceMutex.RLock()
	defer fake.getArgsSliceMutex.RUnlock()
	return len(fake.getArgsSliceArgsForCall)
}

func (fake *MockStub) GetArgsSliceReturns(result1 []byte, result2 error) {
	fake.GetArgsSliceStub = nil
	fake.getArgsSliceReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetArgsSliceReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.GetArgsSliceStub = nil
	if fake.getArgsSliceReturnsOnCall == nil {
		fake.getArgsSliceReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getArgsSliceReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetTxID() string {
	fake.getTxIDMutex.Lock()
	ret, specificReturn := fake.getTxIDReturnsOnCall[len(fake.getTxIDArgsForCall)]
	fake.getTxIDArgsForCall = append(fake.getTxIDArgsForCall, struct{}{})
	fake.recordInvocation("GetTxID", []interface{}{})
	fake.getTxIDMutex.Unlock()
	if fake.GetTxIDStub != nil {
		return fake.GetTxIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getTxIDReturns.result1
}

func (fake *MockStub) GetTxIDCallCount() int {
	fake.getTxIDMutex.RLock()
	defer fake.getTxIDMutex.RUnlock()
	return len(fake.getTxIDArgsForCall)
}

func (fake *MockStub) GetTxIDReturns(result1 string) {
	fake.GetTxIDStub = nil
	fake.getTxIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *MockStub) GetTxIDReturnsOnCall(i int, result1 string) {
	fake.GetTxIDStub = nil
	if fake.getTxIDReturnsOnCall == nil {
		fake.getTxIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getTxIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *MockStub) GetChannelID() string {
	fake.getChannelIDMutex.Lock()
	ret, specificReturn := fake.getChannelIDReturnsOnCall[len(fake.getChannelIDArgsForCall)]
	fake.getChannelIDArgsForCall = append(fake.getChannelIDArgsForCall, struct{}{})
	fake.recordInvocation("GetChannelID", []interface{}{})
	fake.getChannelIDMutex.Unlock()
	if fake.GetChannelIDStub != nil {
		return fake.GetChannelIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getChannelIDReturns.result1
}

func (fake *MockStub) GetChannelIDCallCount() int {
	fake.getChannelIDMutex.RLock()
	defer fake.getChannelIDMutex.RUnlock()
	return len(fake.getChannelIDArgsForCall)
}

func (fake *MockStub) GetChannelIDReturns(result1 string) {
	fake.GetChannelIDStub = nil
	fake.getChannelIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *MockStub) GetChannelIDReturnsOnCall(i int, result1 string) {
	fake.GetChannelIDStub = nil
	if fake.getChannelIDReturnsOnCall == nil {
		fake.getChannelIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getChannelIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *MockStub) InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response {
	var argsCopy [][]byte
	if args != nil {
		argsCopy = make([][]byte, len(args))
		copy(argsCopy, args)
	}
	fake.invokeChaincodeMutex.Lock()
	ret, specificReturn := fake.invokeChaincodeReturnsOnCall[len(fake.invokeChaincodeArgsForCall)]
	fake.invokeChaincodeArgsForCall = append(fake.invokeChaincodeArgsForCall, struct {
		chaincodeName string
		args          [][]byte
		channel       string
	}{chaincodeName, argsCopy, channel})
	fake.recordInvocation("InvokeChaincode", []interface{}{chaincodeName, argsCopy, channel})
	fake.invokeChaincodeMutex.Unlock()
	if fake.InvokeChaincodeStub != nil {
		return fake.InvokeChaincodeStub(chaincodeName, args, channel)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.invokeChaincodeReturns.result1
}

func (fake *MockStub) InvokeChaincodeCallCount() int {
	fake.invokeChaincodeMutex.RLock()
	defer fake.invokeChaincodeMutex.RUnlock()
	return len(fake.invokeChaincodeArgsForCall)
}

func (fake *MockStub) InvokeChaincodeArgsForCall(i int) (string, [][]byte, string) {
	fake.invokeChaincodeMutex.RLock()
	defer fake.invokeChaincodeMutex.RUnlock()
	return fake.invokeChaincodeArgsForCall[i].chaincodeName, fake.invokeChaincodeArgsForCall[i].args, fake.invokeChaincodeArgsForCall[i].channel
}

func (fake *MockStub) InvokeChaincodeReturns(result1 pb.Response) {
	fake.InvokeChaincodeStub = nil
	fake.invokeChaincodeReturns = struct {
		result1 pb.Response
	}{result1}
}

func (fake *MockStub) InvokeChaincodeReturnsOnCall(i int, result1 pb.Response) {
	fake.InvokeChaincodeStub = nil
	if fake.invokeChaincodeReturnsOnCall == nil {
		fake.invokeChaincodeReturnsOnCall = make(map[int]struct {
			result1 pb.Response
		})
	}
	fake.invokeChaincodeReturnsOnCall[i] = struct {
		result1 pb.Response
	}{result1}
}

func (fake *MockStub) GetState(key string) ([]byte, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetState", []interface{}{key})
	fake.getStateMutex.Unlock()
	if fake.GetStateStub != nil {
		return fake.GetStateStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStateReturns.result1, fake.getStateReturns.result2
}

func (fake *MockStub) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *MockStub) GetStateArgsForCall(i int) string {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return fake.getStateArgsForCall[i].key
}

func (fake *MockStub) GetStateReturns(result1 []byte, result2 error) {
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetStateReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) PutState(key string, value []byte) error {
	var valueCopy []byte
	if value != nil {
		valueCopy = make([]byte, len(value))
		copy(valueCopy, value)
	}
	fake.putStateMutex.Lock()
	ret, specificReturn := fake.putStateReturnsOnCall[len(fake.putStateArgsForCall)]
	fake.putStateArgsForCall = append(fake.putStateArgsForCall, struct {
		key   string
		value []byte
	}{key, valueCopy})
	fake.recordInvocation("PutState", []interface{}{key, valueCopy})
	fake.putStateMutex.Unlock()
	if fake.PutStateStub != nil {
		return fake.PutStateStub(key, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.putStateReturns.result1
}

func (fake *MockStub) PutStateCallCount() int {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	return len(fake.putStateArgsForCall)
}

func (fake *MockStub) PutStateArgsForCall(i int) (string, []byte) {
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	return fake.putStateArgsForCall[i].key, fake.putStateArgsForCall[i].value
}

func (fake *MockStub) PutStateReturns(result1 error) {
	fake.PutStateStub = nil
	fake.putStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockStub) PutStateReturnsOnCall(i int, result1 error) {
	fake.PutStateStub = nil
	if fake.putStateReturnsOnCall == nil {
		fake.putStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockStub) DelState(key string) error {
	fake.delStateMutex.Lock()
	ret, specificReturn := fake.delStateReturnsOnCall[len(fake.delStateArgsForCall)]
	fake.delStateArgsForCall = append(fake.delStateArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("DelState", []interface{}{key})
	fake.delStateMutex.Unlock()
	if fake.DelStateStub != nil {
		return fake.DelStateStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.delStateReturns.result1
}

func (fake *MockStub) DelStateCallCount() int {
	fake.delStateMutex.RLock()
	defer fake.delStateMutex.RUnlock()
	return len(fake.delStateArgsForCall)
}

func (fake *MockStub) DelStateArgsForCall(i int) string {
	fake.delStateMutex.RLock()
	defer fake.delStateMutex.RUnlock()
	return fake.delStateArgsForCall[i].key
}

func (fake *MockStub) DelStateReturns(result1 error) {
	fake.DelStateStub = nil
	fake.delStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockStub) DelStateReturnsOnCall(i int, result1 error) {
	fake.DelStateStub = nil
	if fake.delStateReturnsOnCall == nil {
		fake.delStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.delStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockStub) GetStateByRange(startKey string, endKey string) (shim.StateQueryIteratorInterface, error) {
	fake.getStateByRangeMutex.Lock()
	ret, specificReturn := fake.getStateByRangeReturnsOnCall[len(fake.getStateByRangeArgsForCall)]
	fake.getStateByRangeArgsForCall = append(fake.getStateByRangeArgsForCall, struct {
		startKey string
		endKey   string
	}{startKey, endKey})
	fake.recordInvocation("GetStateByRange", []interface{}{startKey, endKey})
	fake.getStateByRangeMutex.Unlock()
	if fake.GetStateByRangeStub != nil {
		return fake.GetStateByRangeStub(startKey, endKey)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStateByRangeReturns.result1, fake.getStateByRangeReturns.result2
}

func (fake *MockStub) GetStateByRangeCallCount() int {
	fake.getStateByRangeMutex.RLock()
	defer fake.getStateByRangeMutex.RUnlock()
	return len(fake.getStateByRangeArgsForCall)
}

func (fake *MockStub) GetStateByRangeArgsForCall(i int) (string, string) {
	fake.getStateByRangeMutex.RLock()
	defer fake.getStateByRangeMutex.RUnlock()
	return fake.getStateByRangeArgsForCall[i].startKey, fake.getStateByRangeArgsForCall[i].endKey
}

func (fake *MockStub) GetStateByRangeReturns(result1 shim.StateQueryIteratorInterface, result2 error) {
	fake.GetStateByRangeStub = nil
	fake.getStateByRangeReturns = struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetStateByRangeReturnsOnCall(i int, result1 shim.StateQueryIteratorInterface, result2 error) {
	fake.GetStateByRangeStub = nil
	if fake.getStateByRangeReturnsOnCall == nil {
		fake.getStateByRangeReturnsOnCall = make(map[int]struct {
			result1 shim.StateQueryIteratorInterface
			result2 error
		})
	}
	fake.getStateByRangeReturnsOnCall[i] = struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetStateByPartialCompositeKey(objectType string, keys []string) (shim.StateQueryIteratorInterface, error) {
	var keysCopy []string
	if keys != nil {
		keysCopy = make([]string, len(keys))
		copy(keysCopy, keys)
	}
	fake.getStateByPartialCompositeKeyMutex.Lock()
	ret, specificReturn := fake.getStateByPartialCompositeKeyReturnsOnCall[len(fake.getStateByPartialCompositeKeyArgsForCall)]
	fake.getStateByPartialCompositeKeyArgsForCall = append(fake.getStateByPartialCompositeKeyArgsForCall, struct {
		objectType string
		keys       []string
	}{objectType, keysCopy})
	fake.recordInvocation("GetStateByPartialCompositeKey", []interface{}{objectType, keysCopy})
	fake.getStateByPartialCompositeKeyMutex.Unlock()
	if fake.GetStateByPartialCompositeKeyStub != nil {
		return fake.GetStateByPartialCompositeKeyStub(objectType, keys)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStateByPartialCompositeKeyReturns.result1, fake.getStateByPartialCompositeKeyReturns.result2
}

func (fake *MockStub) GetStateByPartialCompositeKeyCallCount() int {
	fake.getStateByPartialCompositeKeyMutex.RLock()
	defer fake.getStateByPartialCompositeKeyMutex.RUnlock()
	return len(fake.getStateByPartialCompositeKeyArgsForCall)
}

func (fake *MockStub) GetStateByPartialCompositeKeyArgsForCall(i int) (string, []string) {
	fake.getStateByPartialCompositeKeyMutex.RLock()
	defer fake.getStateByPartialCompositeKeyMutex.RUnlock()
	return fake.getStateByPartialCompositeKeyArgsForCall[i].objectType, fake.getStateByPartialCompositeKeyArgsForCall[i].keys
}

func (fake *MockStub) GetStateByPartialCompositeKeyReturns(result1 shim.StateQueryIteratorInterface, result2 error) {
	fake.GetStateByPartialCompositeKeyStub = nil
	fake.getStateByPartialCompositeKeyReturns = struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetStateByPartialCompositeKeyReturnsOnCall(i int, result1 shim.StateQueryIteratorInterface, result2 error) {
	fake.GetStateByPartialCompositeKeyStub = nil
	if fake.getStateByPartialCompositeKeyReturnsOnCall == nil {
		fake.getStateByPartialCompositeKeyReturnsOnCall = make(map[int]struct {
			result1 shim.StateQueryIteratorInterface
			result2 error
		})
	}
	fake.getStateByPartialCompositeKeyReturnsOnCall[i] = struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) CreateCompositeKey(objectType string, attributes []string) (string, error) {
	var attributesCopy []string
	if attributes != nil {
		attributesCopy = make([]string, len(attributes))
		copy(attributesCopy, attributes)
	}
	fake.createCompositeKeyMutex.Lock()
	ret, specificReturn := fake.createCompositeKeyReturnsOnCall[len(fake.createCompositeKeyArgsForCall)]
	fake.createCompositeKeyArgsForCall = append(fake.createCompositeKeyArgsForCall, struct {
		objectType string
		attributes []string
	}{objectType, attributesCopy})
	fake.recordInvocation("CreateCompositeKey", []interface{}{objectType, attributesCopy})
	fake.createCompositeKeyMutex.Unlock()
	if fake.CreateCompositeKeyStub != nil {
		return fake.CreateCompositeKeyStub(objectType, attributes)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createCompositeKeyReturns.result1, fake.createCompositeKeyReturns.result2
}

func (fake *MockStub) CreateCompositeKeyCallCount() int {
	fake.createCompositeKeyMutex.RLock()
	defer fake.createCompositeKeyMutex.RUnlock()
	return len(fake.createCompositeKeyArgsForCall)
}

func (fake *MockStub) CreateCompositeKeyArgsForCall(i int) (string, []string) {
	fake.createCompositeKeyMutex.RLock()
	defer fake.createCompositeKeyMutex.RUnlock()
	return fake.createCompositeKeyArgsForCall[i].objectType, fake.createCompositeKeyArgsForCall[i].attributes
}

func (fake *MockStub) CreateCompositeKeyReturns(result1 string, result2 error) {
	fake.CreateCompositeKeyStub = nil
	fake.createCompositeKeyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *MockStub) CreateCompositeKeyReturnsOnCall(i int, result1 string, result2 error) {
	fake.CreateCompositeKeyStub = nil
	if fake.createCompositeKeyReturnsOnCall == nil {
		fake.createCompositeKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createCompositeKeyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *MockStub) SplitCompositeKey(compositeKey string) (string, []string, error) {
	fake.splitCompositeKeyMutex.Lock()
	ret, specificReturn := fake.splitCompositeKeyReturnsOnCall[len(fake.splitCompositeKeyArgsForCall)]
	fake.splitCompositeKeyArgsForCall = append(fake.splitCompositeKeyArgsForCall, struct {
		compositeKey string
	}{compositeKey})
	fake.recordInvocation("SplitCompositeKey", []interface{}{compositeKey})
	fake.splitCompositeKeyMutex.Unlock()
	if fake.SplitCompositeKeyStub != nil {
		return fake.SplitCompositeKeyStub(compositeKey)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.splitCompositeKeyReturns.result1, fake.splitCompositeKeyReturns.result2, fake.splitCompositeKeyReturns.result3
}

func (fake *MockStub) SplitCompositeKeyCallCount() int {
	fake.splitCompositeKeyMutex.RLock()
	defer fake.splitCompositeKeyMutex.RUnlock()
	return len(fake.splitCompositeKeyArgsForCall)
}

func (fake *MockStub) SplitCompositeKeyArgsForCall(i int) string {
	fake.splitCompositeKeyMutex.RLock()
	defer fake.splitCompositeKeyMutex.RUnlock()
	return fake.splitCompositeKeyArgsForCall[i].compositeKey
}

func (fake *MockStub) SplitCompositeKeyReturns(result1 string, result2 []string, result3 error) {
	fake.SplitCompositeKeyStub = nil
	fake.splitCompositeKeyReturns = struct {
		result1 string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *MockStub) SplitCompositeKeyReturnsOnCall(i int, result1 string, result2 []string, result3 error) {
	fake.SplitCompositeKeyStub = nil
	if fake.splitCompositeKeyReturnsOnCall == nil {
		fake.splitCompositeKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 []string
			result3 error
		})
	}
	fake.splitCompositeKeyReturnsOnCall[i] = struct {
		result1 string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *MockStub) GetQueryResult(query string) (shim.StateQueryIteratorInterface, error) {
	fake.getQueryResultMutex.Lock()
	ret, specificReturn := fake.getQueryResultReturnsOnCall[len(fake.getQueryResultArgsForCall)]
	fake.getQueryResultArgsForCall = append(fake.getQueryResultArgsForCall, struct {
		query string
	}{query})
	fake.recordInvocation("GetQueryResult", []interface{}{query})
	fake.getQueryResultMutex.Unlock()
	if fake.GetQueryResultStub != nil {
		return fake.GetQueryResultStub(query)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getQueryResultReturns.result1, fake.getQueryResultReturns.result2
}

func (fake *MockStub) GetQueryResultCallCount() int {
	fake.getQueryResultMutex.RLock()
	defer fake.getQueryResultMutex.RUnlock()
	return len(fake.getQueryResultArgsForCall)
}

func (fake *MockStub) GetQueryResultArgsForCall(i int) string {
	fake.getQueryResultMutex.RLock()
	defer fake.getQueryResultMutex.RUnlock()
	return fake.getQueryResultArgsForCall[i].query
}

func (fake *MockStub) GetQueryResultReturns(result1 shim.StateQueryIteratorInterface, result2 error) {
	fake.GetQueryResultStub = nil
	fake.getQueryResultReturns = struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetQueryResultReturnsOnCall(i int, result1 shim.StateQueryIteratorInterface, result2 error) {
	fake.GetQueryResultStub = nil
	if fake.getQueryResultReturnsOnCall == nil {
		fake.getQueryResultReturnsOnCall = make(map[int]struct {
			result1 shim.StateQueryIteratorInterface
			result2 error
		})
	}
	fake.getQueryResultReturnsOnCall[i] = struct {
		result1 shim.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetHistoryForKey(key string) (shim.HistoryQueryIteratorInterface, error) {
	fake.getHistoryForKeyMutex.Lock()
	ret, specificReturn := fake.getHistoryForKeyReturnsOnCall[len(fake.getHistoryForKeyArgsForCall)]
	fake.getHistoryForKeyArgsForCall = append(fake.getHistoryForKeyArgsForCall, struct {
		key string
	}{key})
	fake.recordInvocation("GetHistoryForKey", []interface{}{key})
	fake.getHistoryForKeyMutex.Unlock()
	if fake.GetHistoryForKeyStub != nil {
		return fake.GetHistoryForKeyStub(key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getHistoryForKeyReturns.result1, fake.getHistoryForKeyReturns.result2
}

func (fake *MockStub) GetHistoryForKeyCallCount() int {
	fake.getHistoryForKeyMutex.RLock()
	defer fake.getHistoryForKeyMutex.RUnlock()
	return len(fake.getHistoryForKeyArgsForCall)
}

func (fake *MockStub) GetHistoryForKeyArgsForCall(i int) string {
	fake.getHistoryForKeyMutex.RLock()
	defer fake.getHistoryForKeyMutex.RUnlock()
	return fake.getHistoryForKeyArgsForCall[i].key
}

func (fake *MockStub) GetHistoryForKeyReturns(result1 shim.HistoryQueryIteratorInterface, result2 error) {
	fake.GetHistoryForKeyStub = nil
	fake.getHistoryForKeyReturns = struct {
		result1 shim.HistoryQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetHistoryForKeyReturnsOnCall(i int, result1 shim.HistoryQueryIteratorInterface, result2 error) {
	fake.GetHistoryForKeyStub = nil
	if fake.getHistoryForKeyReturnsOnCall == nil {
		fake.getHistoryForKeyReturnsOnCall = make(map[int]struct {
			result1 shim.HistoryQueryIteratorInterface
			result2 error
		})
	}
	fake.getHistoryForKeyReturnsOnCall[i] = struct {
		result1 shim.HistoryQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetCreator() ([]byte, error) {
	fake.getCreatorMutex.Lock()
	ret, specificReturn := fake.getCreatorReturnsOnCall[len(fake.getCreatorArgsForCall)]
	fake.getCreatorArgsForCall = append(fake.getCreatorArgsForCall, struct{}{})
	fake.recordInvocation("GetCreator", []interface{}{})
	fake.getCreatorMutex.Unlock()
	if fake.GetCreatorStub != nil {
		return fake.GetCreatorStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCreatorReturns.result1, fake.getCreatorReturns.result2
}

func (fake *MockStub) GetCreatorCallCount() int {
	fake.getCreatorMutex.RLock()
	defer fake.getCreatorMutex.RUnlock()
	return len(fake.getCreatorArgsForCall)
}

func (fake *MockStub) GetCreatorReturns(result1 []byte, result2 error) {
	fake.GetCreatorStub = nil
	fake.getCreatorReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetCreatorReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.GetCreatorStub = nil
	if fake.getCreatorReturnsOnCall == nil {
		fake.getCreatorReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getCreatorReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetTransient() (map[string][]byte, error) {
	fake.getTransientMutex.Lock()
	ret, specificReturn := fake.getTransientReturnsOnCall[len(fake.getTransientArgsForCall)]
	fake.getTransientArgsForCall = append(fake.getTransientArgsForCall, struct{}{})
	fake.recordInvocation("GetTransient", []interface{}{})
	fake.getTransientMutex.Unlock()
	if fake.GetTransientStub != nil {
		return fake.GetTransientStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTransientReturns.result1, fake.getTransientReturns.result2
}

func (fake *MockStub) GetTransientCallCount() int {
	fake.getTransientMutex.RLock()
	defer fake.getTransientMutex.RUnlock()
	return len(fake.getTransientArgsForCall)
}

func (fake *MockStub) GetTransientReturns(result1 map[string][]byte, result2 error) {
	fake.GetTransientStub = nil
	fake.getTransientReturns = struct {
		result1 map[string][]byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetTransientReturnsOnCall(i int, result1 map[string][]byte, result2 error) {
	fake.GetTransientStub = nil
	if fake.getTransientReturnsOnCall == nil {
		fake.getTransientReturnsOnCall = make(map[int]struct {
			result1 map[string][]byte
			result2 error
		})
	}
	fake.getTransientReturnsOnCall[i] = struct {
		result1 map[string][]byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetBinding() ([]byte, error) {
	fake.getBindingMutex.Lock()
	ret, specificReturn := fake.getBindingReturnsOnCall[len(fake.getBindingArgsForCall)]
	fake.getBindingArgsForCall = append(fake.getBindingArgsForCall, struct{}{})
	fake.recordInvocation("GetBinding", []interface{}{})
	fake.getBindingMutex.Unlock()
	if fake.GetBindingStub != nil {
		return fake.GetBindingStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBindingReturns.result1, fake.getBindingReturns.result2
}

func (fake *MockStub) GetBindingCallCount() int {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	return len(fake.getBindingArgsForCall)
}

func (fake *MockStub) GetBindingReturns(result1 []byte, result2 error) {
	fake.GetBindingStub = nil
	fake.getBindingReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetBindingReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.GetBindingStub = nil
	if fake.getBindingReturnsOnCall == nil {
		fake.getBindingReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getBindingReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetDecorations() map[string][]byte {
	fake.getDecorationsMutex.Lock()
	ret, specificReturn := fake.getDecorationsReturnsOnCall[len(fake.getDecorationsArgsForCall)]
	fake.getDecorationsArgsForCall = append(fake.getDecorationsArgsForCall, struct{}{})
	fake.recordInvocation("GetDecorations", []interface{}{})
	fake.getDecorationsMutex.Unlock()
	if fake.GetDecorationsStub != nil {
		return fake.GetDecorationsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getDecorationsReturns.result1
}

func (fake *MockStub) GetDecorationsCallCount() int {
	fake.getDecorationsMutex.RLock()
	defer fake.getDecorationsMutex.RUnlock()
	return len(fake.getDecorationsArgsForCall)
}

func (fake *MockStub) GetDecorationsReturns(result1 map[string][]byte) {
	fake.GetDecorationsStub = nil
	fake.getDecorationsReturns = struct {
		result1 map[string][]byte
	}{result1}
}

func (fake *MockStub) GetDecorationsReturnsOnCall(i int, result1 map[string][]byte) {
	fake.GetDecorationsStub = nil
	if fake.getDecorationsReturnsOnCall == nil {
		fake.getDecorationsReturnsOnCall = make(map[int]struct {
			result1 map[string][]byte
		})
	}
	fake.getDecorationsReturnsOnCall[i] = struct {
		result1 map[string][]byte
	}{result1}
}

func (fake *MockStub) GetSignedProposal() (*pb.SignedProposal, error) {
	fake.getSignedProposalMutex.Lock()
	ret, specificReturn := fake.getSignedProposalReturnsOnCall[len(fake.getSignedProposalArgsForCall)]
	fake.getSignedProposalArgsForCall = append(fake.getSignedProposalArgsForCall, struct{}{})
	fake.recordInvocation("GetSignedProposal", []interface{}{})
	fake.getSignedProposalMutex.Unlock()
	if fake.GetSignedProposalStub != nil {
		return fake.GetSignedProposalStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getSignedProposalReturns.result1, fake.getSignedProposalReturns.result2
}

func (fake *MockStub) GetSignedProposalCallCount() int {
	fake.getSignedProposalMutex.RLock()
	defer fake.getSignedProposalMutex.RUnlock()
	return len(fake.getSignedProposalArgsForCall)
}

func (fake *MockStub) GetSignedProposalReturns(result1 *pb.SignedProposal, result2 error) {
	fake.GetSignedProposalStub = nil
	fake.getSignedProposalReturns = struct {
		result1 *pb.SignedProposal
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetSignedProposalReturnsOnCall(i int, result1 *pb.SignedProposal, result2 error) {
	fake.GetSignedProposalStub = nil
	if fake.getSignedProposalReturnsOnCall == nil {
		fake.getSignedProposalReturnsOnCall = make(map[int]struct {
			result1 *pb.SignedProposal
			result2 error
		})
	}
	fake.getSignedProposalReturnsOnCall[i] = struct {
		result1 *pb.SignedProposal
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetTxTimestamp() (*timestamp.Timestamp, error) {
	fake.getTxTimestampMutex.Lock()
	ret, specificReturn := fake.getTxTimestampReturnsOnCall[len(fake.getTxTimestampArgsForCall)]
	fake.getTxTimestampArgsForCall = append(fake.getTxTimestampArgsForCall, struct{}{})
	fake.recordInvocation("GetTxTimestamp", []interface{}{})
	fake.getTxTimestampMutex.Unlock()
	if fake.GetTxTimestampStub != nil {
		return fake.GetTxTimestampStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getTxTimestampReturns.result1, fake.getTxTimestampReturns.result2
}

func (fake *MockStub) GetTxTimestampCallCount() int {
	fake.getTxTimestampMutex.RLock()
	defer fake.getTxTimestampMutex.RUnlock()
	return len(fake.getTxTimestampArgsForCall)
}

func (fake *MockStub) GetTxTimestampReturns(result1 *timestamp.Timestamp, result2 error) {
	fake.GetTxTimestampStub = nil
	fake.getTxTimestampReturns = struct {
		result1 *timestamp.Timestamp
		result2 error
	}{result1, result2}
}

func (fake *MockStub) GetTxTimestampReturnsOnCall(i int, result1 *timestamp.Timestamp, result2 error) {
	fake.GetTxTimestampStub = nil
	if fake.getTxTimestampReturnsOnCall == nil {
		fake.getTxTimestampReturnsOnCall = make(map[int]struct {
			result1 *timestamp.Timestamp
			result2 error
		})
	}
	fake.getTxTimestampReturnsOnCall[i] = struct {
		result1 *timestamp.Timestamp
		result2 error
	}{result1, result2}
}

func (fake *MockStub) SetEvent(name string, payload []byte) error {
	var payloadCopy []byte
	if payload != nil {
		payloadCopy = make([]byte, len(payload))
		copy(payloadCopy, payload)
	}
	fake.setEventMutex.Lock()
	ret, specificReturn := fake.setEventReturnsOnCall[len(fake.setEventArgsForCall)]
	fake.setEventArgsForCall = append(fake.setEventArgsForCall, struct {
		name    string
		payload []byte
	}{name, payloadCopy})
	fake.recordInvocation("SetEvent", []interface{}{name, payloadCopy})
	fake.setEventMutex.Unlock()
	if fake.SetEventStub != nil {
		return fake.SetEventStub(name, payload)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setEventReturns.result1
}

func (fake *MockStub) SetEventCallCount() int {
	fake.setEventMutex.RLock()
	defer fake.setEventMutex.RUnlock()
	return len(fake.setEventArgsForCall)
}

func (fake *MockStub) SetEventArgsForCall(i int) (string, []byte) {
	fake.setEventMutex.RLock()
	defer fake.setEventMutex.RUnlock()
	return fake.setEventArgsForCall[i].name, fake.setEventArgsForCall[i].payload
}

func (fake *MockStub) SetEventReturns(result1 error) {
	fake.SetEventStub = nil
	fake.setEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *MockStub) SetEventReturnsOnCall(i int, result1 error) {
	fake.SetEventStub = nil
	if fake.setEventReturnsOnCall == nil {
		fake.setEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *MockStub) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getArgsMutex.RLock()
	defer fake.getArgsMutex.RUnlock()
	fake.getStringArgsMutex.RLock()
	defer fake.getStringArgsMutex.RUnlock()
	fake.getFunctionAndParametersMutex.RLock()
	defer fake.getFunctionAndParametersMutex.RUnlock()
	fake.getArgsSliceMutex.RLock()
	defer fake.getArgsSliceMutex.RUnlock()
	fake.getTxIDMutex.RLock()
	defer fake.getTxIDMutex.RUnlock()
	fake.getChannelIDMutex.RLock()
	defer fake.getChannelIDMutex.RUnlock()
	fake.invokeChaincodeMutex.RLock()
	defer fake.invokeChaincodeMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.putStateMutex.RLock()
	defer fake.putStateMutex.RUnlock()
	fake.delStateMutex.RLock()
	defer fake.delStateMutex.RUnlock()
	fake.getStateByRangeMutex.RLock()
	defer fake.getStateByRangeMutex.RUnlock()
	fake.getStateByPartialCompositeKeyMutex.RLock()
	defer fake.getStateByPartialCompositeKeyMutex.RUnlock()
	fake.createCompositeKeyMutex.RLock()
	defer fake.createCompositeKeyMutex.RUnlock()
	fake.splitCompositeKeyMutex.RLock()
	defer fake.splitCompositeKeyMutex.RUnlock()
	fake.getQueryResultMutex.RLock()
	defer fake.getQueryResultMutex.RUnlock()
	fake.getHistoryForKeyMutex.RLock()
	defer fake.getHistoryForKeyMutex.RUnlock()
	fake.getCreatorMutex.RLock()
	defer fake.getCreatorMutex.RUnlock()
	fake.getTransientMutex.RLock()
	defer fake.getTransientMutex.RUnlock()
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	fake.getDecorationsMutex.RLock()
	defer fake.getDecorationsMutex.RUnlock()
	fake.getSignedProposalMutex.RLock()
	defer fake.getSignedProposalMutex.RUnlock()
	fake.getTxTimestampMutex.RLock()
	defer fake.getTxTimestampMutex.RUnlock()
	fake.setEventMutex.RLock()
	defer fake.setEventMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *MockStub) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ shim.ChaincodeStubInterface = new(MockStub)
